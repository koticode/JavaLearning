package lesson15_upgrade;

public abstract class Hero implements Mortal { // Для демонстрации использования интерфейса в классах. Т.к. интерфейсы являются одним из способов реализации полиморфизма

    /**
     * Воспользуемся принципом ООП - абстракцией, согласно которому для создания объектов нам нужно выделять только ключевые их свойства, важные в рамках решаемой задачи.
     * Создадим 3 приватных поля, определим 3 метода(неизменны для всех объектов), переопределим метод из интерфейса, создадим 1 абстрактный метод (для переопределения в классах конкретных персонажей)
     * Принцип инкапсуляции - мы собрали все свойства класса внутри него, а также скрыли приватные поля от пользователя, и предоставили лишь удобный интерфейс для работы с ними (в виде getter и setter)
     * Принцип наследования - от этого класса поля и методы наследуют другие классы. Данный класс я решил создать абстрактным, чтобы создать объекты можно было только на основе классов - наследников.
     * Принцип полиморфизма - может быть реализован как через extends (наследование), так и через implements(использование интерфейсов)
     * Полиморфизм реализовал здесь обоими путями - переопределен метод интерфейса в этом классе, и переопределен абстрактный метод hit() в каждом классе - наследнике.
     */
    private final String name;
    private int health;
    private final int damage;

    public Hero(String name, int damage, int health) { // конструктор для создания персонажей
        this.name = name;
        this.damage = damage;
        this.health = health;
    }

    public void attackEnemy(Hero hero) { // здесь указываем врага, которого нужно атаковать
        System.out.println(getName() + hit()+ hero.getName());
        hero.takeDamage(Hero.this); // передаем в метод takeDamage, кто именно атакует и наносит урон, чтобы атакуемый персонаж его "принял"
        if (hero.health!=0){
            this.takeDamage(hero); // подвергшийся атаке персонаж наносит ответный удар при нападении на себя (если после удара у него еще остались единицы здоровья)
        }
    }
    public void takeDamage(Hero attacker) { // Указываем, кто нас атакует, чтобы иметь доступ к его урону и здоровью, т.к. мы атакуем в ответ
        if (isAlive() && health <= attacker.getDamage()) {
            health = 0;
            System.out.println(getName() + " погиб");
        } else {
            this.health -= Math.min(health, attacker.getDamage()); // чтобы здоровье не ушло в минус, выбираем наименьшее значение - либо здоровье, либо урон
            System.out.println(name + " получил урон " + attacker.getDamage() + ". Осталось " + health);
        }
    }

    public abstract String hit(); // пример абстрактного метода, который надо обязательно переопределить в классах, наследующих от Hero

    @Override
    public boolean isAlive() {
        return health>0;
    }

    public String getName() {
        return name;
    }
    public int getHealth() {
        return health;
    }

    public int getDamage() {
        return damage;
    }

}

